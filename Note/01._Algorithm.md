# 01. Algorithm

## 1) Algorithm의 개요

### Alogrithm이란

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법

  - 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법

  - 어떠한 문제를 해결하기 위한 절차

    `ex)` 1부터 100까지 합을 구하는 문제

    Algorithm 1)
    $$
    1+2+3+ ...+99+100 = 5050
    $$
Algorithm 2)
    $$
    {\{(1+100)+(2+99)+(3+98)+...+(100+1)\}\over2}={100 \times 101\over 2} = 5050
    $$



### Algorithm 표기법

- 슈도코드(Pseudo Code)

  - 특정 프로그래밍 언어의 문법에 따라 쓰여진 것이 아니라 일반적인 언어로 코드를 흉내내어 써 놓은 코드

  - 의사코드로 흉내만 내는 코드
  - 실제적인 프로그래밍 언어로 작성된 코드처럼 컴퓨터에서 실행할 수 없음
  - 특정 언어로 프로그램을 작성하기 전에 알고리즘의 모델을 대략적으로 모델링 하는데 쓰임

- 순서도(흐름도)
  - 프로그램이나 작업의 진행흐름을 순서에 따라 여러가지 기호나 문자로 나타낸 도표
  - 프로그램의 논리적인 흐름 , 데이터의 처리과정을 표현하는데 사용
  - 프로그램을 작성하기 전에 프로그램의 전체적인 흐름과 과정 파악을 위해 거처야 되는 작업





## 2. Algorithm의 성능분석

### 무엇이 좋은 Algorithm인가?

- 정확성 : 얼마나 정확하게 동작하는가?
- 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가?
- 메모리 사용량 : 얼마나 적은 메모리를 사용하는가?
- 단순성 : 얼마나 단순한가?
- 최적성 : 더 이상 개선할 여지없이 최적화 되었는가?



### Algorithm의 성능 분석 필요

- 많은 문제에서 성능 분석을 기준으로 Algorithm의 작업량을 비교

  Algorithm 1)
  $$
  1+2+3+ ...+99+100 = 5050
  $$

  - 99번의 연산(덧셈 99번)

  Algorithm 2) 
  $$
  {100 \times 101\over 2} = 5050
  $$

  - 3번의 연산(덧셈 1번, 곱셈 1번, 나눗셈 1번)

  **:star:더하려는 범위가 클수록 연산 횟수의 차이는 커짐.:star:**



### 시간복잡도(Time Complexity)

- 측정 방법

  - 실제 걸리는 시간을 측정

  - **:star:실행되는 명령문의 개수를 계산:star:**

    Algorithm 1)

    ```java
    sum(n){
    	i <- start;
    	sum <- 0;
    	for(; i <= n; i <- i + 1){
    		sum <- sum + i;
    	}
    	return sum;
    }
    ```

    - 연산 횟수 : 3n+2

    Algorithm 2)

    ```java
    sum(n){
        count <- n;
        sum <- n + 1;
        sum <- sum * count;
        sum <- sum / 2;
        return sum;
    }
    ```

    - 연산 횟수 : 4



### 빅오(Big-O) 표기법

- 시간복잡도 함수 중에서 가장큰 영향력을 주는 n에 대한 항만을 표시

- 계수(coefficient)는 생략하여 표시

  `ex)`
  $$
  O(3n+2) = O(3n) = O(n)
  $$

  $$
  O(2n^2+10n+100) = O(n^2)
  $$

  $$
  O(4)=O(1)
  $$

- 요소 수가 증가함에 따라 각기 다른 시간복잡도의 알고리즘은 아래와 같은 연산수를 보임

  ![ìì¤ ì´ë¯¸ì§ ë³´ê¸°](D:\SSAFY\Typora_res\th.png)

